import operator
import string
import random
import __future__

TARGET_NUMBER = 60
CROSS_OVER_RATE = 0.7
MUTATION_RATE = 0.1
POPULATION = 50

gene_table = {'0000': '0',
              '0001': '1',
              '0010': '2',
              '0011': '3',
              '0100': '4',
              '0101': '5',
              '0110': '6',
              '0111': '7',
              '1000': '8',
              '1001': '9',
              '1010': '+',
              '1011': '-',
              '1100': '*',
              '1101': '/',
              '1110': 'X',
              '1111': 'X'}


def parse_chromo(chromo, with_log=False):
    input_ls = convert_chromo_table(chromo, 4, gene_table)
    input_str = ""
    for i in input_ls:
        input_str += i
    operators = ['+', '-', '*', '/']
    # State of characters sequence needs to alternate
    is_state_number = True
    filtered_string = ""
    if with_log:
        print "Input: " + input_str
    for i in input_str:
        if is_state_number and i in string.digits:
            filtered_string += i
            is_state_number = not is_state_number
        elif not is_state_number and i in operators:
            filtered_string += i
            is_state_number = not is_state_number
    # Remove the last character if not digit
    if filtered_string[-1:] not in string.digits:
        filtered_string = filtered_string[:-1]
    if with_log:
        print "Filtered: " + filtered_string
    # All the compile stuffs is to make sure it eval the digits as if they were float, otherwise, just a normal eval function
    try:
        ret = eval(compile(filtered_string, '<string>', 'eval', __future__.division.compiler_flag))
    except:
        ret = 0
    return ret

def convert_chromo_table(chromo, step, table):
    """ Convert a <step> amount of bits into what is specified in the table """
    # Table should follow format {"0000": foo, ...}
    ret = []
    for i in range(0, len(chromo), step):
        ret.append(gene_table[chromo[i:i+step]])
    return ret

def generate_chromo():
    ret = ""
    for _ in range(20):
        ret += str(random.randrange(2))
    return ret

def cross_over(chromo_1, chromo_2, rate):
    #cross 2 chromoosomes over, dependant on rate
    if(random.random() < rate):
        pos = random.randrange(20)
        t1 = chromo_1[pos:]
        t2 = chromo_2[pos:]
        chromo_1 = chromo_1[:pos] + t2
        chromo_2 = chromo_2[:pos] + t1
    return (chromo_1, chromo_2)

def mutate(chromo, rate):
    #Each bit in the chromo has a chance to flip its bit
    ret = ""
    for bit in chromo:
        if(random.random() < rate):
            ret += "1" if bit == "0" else "0"
        else:
            ret += bit
    return ret

def reproduce(chromo_1, chromo_2):
    #print "1: {}. 2: {}".format(chromo_1, chromo_2)
    offspring_1, offspring_2 = cross_over(chromo_1, chromo_2, CROSS_OVER_RATE)
    offspring_1 = mutate(offspring_1, MUTATION_RATE)
    offspring_2 = mutate(offspring_2, MUTATION_RATE)
    #print "1: {}. 2: {}".format(offspring_1, offspring_2)

    return (offspring_1, offspring_2)

def get_fitness_score(chromo):
    result = parse_chromo(chromo)
    if(result == TARGET_NUMBER):
        return 2
    else:
        return 1 / float((TARGET_NUMBER - result))

def choose_randomly(probability_dict):
    #dict should follow the format: {item1: prob, item2: prob}
    #Choose randomly using the roulette wheel algo
    prob_sum = 0
    for v in probability_dict.values():
        prob_sum += v
    r = random.random() * prob_sum
    sum_so_far = 0
    for k, v in probability_dict.iteritems():
        sum_so_far += v
        if(r < sum_so_far):
            return k


def population_fitness_avg(population):
    #population should be a dict that follows {chromo: score}
    sum = 0
    for v in population.values():
        sum += v
    sum /= float(len(population.values()))
    return sum


def generate_generation(population):
    new_population = {}
    while(len(new_population) < POPULATION):
        parent_1 = choose_randomly(population)
        parent_2 = choose_randomly(population)
        offspring_1, offspring_2 = reproduce(parent_1, parent_2)
        new_population[offspring_1] = get_fitness_score(offspring_1)
        new_population[offspring_2] = get_fitness_score(offspring_2)
        if new_population[offspring_1] == 2:
            return (offspring_1, 2)
        if new_population[offspring_2] == 2:
            return (offspring_2, 2)
    population = new_population
    #print population
    population_avg = population_fitness_avg(population)
    return (population, population_avg)


if __name__ == "__main__":
    #{chromoosome: fitness_score}
    winning_chromo = ""
    population_avg = []
    population = {}
    for i in range(POPULATION):
        chromo = generate_chromo()
        population[chromo] = get_fitness_score(chromo)
    #print population
    population_avg.append(population_fitness_avg(population))

    for i in range(150):
        population, t_population_avg = generate_generation(population)
        population_avg.append(t_population_avg)
        if type(population) is str:
            winning_chromo = population
            break

    for i, j in zip(population_avg, range(len(population_avg))):
        print "{}: {}".format(j, i)
    print parse_chromo(winning_chromo, True)

